\ SPI FRAM LIBRARY - BYTE WORD DOUBLE - OPTIMIZED
\ v 0.2.
\ USES 16bit TRANSFERS WHERE APPLICABLE
\ FOR FLASHFORTH
\ (c) IgorM 25.5.2015
\ GNU GPL v3
\ No warranties of any kind
\ 
\ FRAM FM25H20 8PIN 256kBytes
\ tested with dspic33fj128gp802
\ 
\	FRAM to PIC wiring (excl. +3.3V VCC and GND):
\
\	FRAM				dsPIC33
\	==================================================
\	fram1_S/	i		CS1 RB15	o
\	fram2_Q		o		SDI1 RB14	i
\	fram5_D		i		SDO1 RB12	o
\	fram6_CLK	i		SCK1 RB13	o
\	==================================================


-spifram
marker -spifram

decimal

\ FRAM opcodes
$06 constant FRAM_WREN 
$02 constant FRAM_WRITE 
$03 constant FRAM_READ 

$02c8 constant trisb
$02ca constant portb
$02cc constant latb
$032c constant adpcfg

$0248 constant SPI1BUF
$0242 constant SPI1CON1
$0240 constant SPI1STAT
$0742 constant OSCCON
$0770 constant PMD1

: SPI1RBF? $0001 SPI1STAT mtst ;				\ wait till SPI1RBF is 1

: FRAM_CS_H $8000 latb mset ;					\ PIN_B15 high
: FRAM_CS_L $8000 latb mclr ;					\ PIN_B15 low

: spiini
	$ffff adpcfg !						\ all RBx digital pins
	$4fff trisb !						\ RB14 input, RB12,13,15 output, 1-input 0-output
	FRAM_CS_H						\ deselect FRAM
	
	$0008 PMD1 mclr						\ enable clock to SPI1 !!!
	
	\ unlock PPS - done in FF already
	
	$ff00 #14 or $06a8 !					\ RPINR20 $06a8 RP14=#14 SDI1
	#8 #8 lshift						\ RPOR6 $06cc	SCKO1	B13 #8
	#7 or $06cc !						\ RPOR6 $06cc	SDO1	B12 #7
	
	$047e SPI1CON1 !					\ set SPI 16bit mode $047e, 8it mode $007e
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

: spi!  ( x --  )
	SPI1BUF !
	begin SPI1RBF? until
	SPI1BUF @ drop						\ must be read !!
	;

: spi@  (  -- x )
	#0 SPI1BUF !
	begin SPI1RBF? until
	SPI1BUF @
	;
	
\ read procedure for reading 1 byte from fram
: rdfram1 ( addrh addr -- x )
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$007e SPI1CON1 !					\ 8bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	dup
	rot
	FRAM_CS_L
	FRAM_READ spi!
	spi!	 						\ addrh
	#8 rshift 
	spi!							\ addr_h
	spi!							\ addr_l
	spi@							\ x in
	FRAM_CS_H
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$047e SPI1CON1 !					\ 16bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

\ write procedure for writing 1 byte to fram
: wrfram1 ( x addrh addr -- )
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$007e SPI1CON1 !					\ 8bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	dup
	rot
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	FRAM_CS_L
	FRAM_WRITE spi!
	spi!							\ addrh
	#8 rshift							
	spi!							\ addr_h
	spi!							\ addr_l
	spi!							\ x out
	FRAM_CS_H
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$047e SPI1CON1 !					\ 16bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

\ read procedure for reading 1 word (16bit) from fram
: rdfram2 ( addrh addr -- x )
	swap
	FRAM_READ #8 lshift or					\ addr FRaddrh
	FRAM_CS_L
	spi!							\ send FRaddrh
	spi!	 						\ send addr
	spi@							\ x
	FRAM_CS_H
	;

\ write procedure for writing 1 word (16bit) to fram
: wrfram2 ( x addrh addr -- )
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$007e SPI1CON1 !					\ 8bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$047e SPI1CON1 !					\ 16bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	swap
	FRAM_WRITE #8 lshift or					\ addr FWaddrh
	FRAM_CS_L
	spi!							\ FWaddrh
	spi!							\ addr
	spi!							\ x
	FRAM_CS_H
	;
	
\ read procedure for reading 1 double (32bit) from fram
: rdfram4 ( addrh addr -- x x )
	swap
	FRAM_READ #8 lshift or					\ addr FRaddrh
	FRAM_CS_L
	spi!							\ send FRaddrh
	spi!							\ send addr
	spi@							\ x
	spi@							\ x
	swap
	FRAM_CS_H
	;

\ write procedure for writing 1 double (32bit) to fram
: wrfram4 ( x x addrh addr -- )
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$007e SPI1CON1 !					\ 8bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$047e SPI1CON1 !					\ 16bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	swap
	FRAM_WRITE #8 lshift or					\ addr FWaddrh
	FRAM_CS_L
	spi!							\ FWaddrh
	spi!							\ addr
	spi!							\ x
	spi!							\ x
	FRAM_CS_H
	;
	
\ TESTING:

2variable data 
$1234 $5678 data 2!	
variable block
2 block !
variable count

spiini

\ data 2@

\ hex

\ Write and Read 40kB of data
\
\ : rfm1a 0 count ! cr 40000 for block @ r@ rdfram1 u. count @ dup u. cr  1 + count ! next ;
\ : wfmt1 ticks 40000 for data @ block @ r@ wrfram1 next ticks swap - . ; 
\ : rfm1 40000 for block @ r@ rdfram1 . cr next ;
\ : rfmt1 ticks 40000 for block @ r@ rdfram1 drop next ticks swap - . ;
\ wfmt1 1114msecs at Fcy=27.648MHz :(
\ rfmt1  900msecs at Fcy=27.648MHz :(
\ 39.7kB/sec average

\ Write and Read 40kB of data
\
\ : wfmt2 0 count ! ticks 20000 for count @ block @ r@ 2* wrfram2 count @ 1+ count ! next ticks swap - . ; 
\ : rfm2 0 count ! cr 20000 for block @ r@ 2* rdfram2 u. count @ dup u. 1+ count ! cr next cr ;
\ : rfmt2 0 count ! ticks 20000 for block @ r@ 2* rdfram2 drop count @ 1+ count ! next ticks swap - . ;
\ wfmt2 555msecs at Fcy=27.648MHz :(
\ rfmt2 372msecs at Fcy=27.648MHz :(
\ 86.3kB/sec average

\ Write and Read 40kB of data
\
\ : wfmt4 0 count ! ticks 10000 for count @ 12345 m* block @ r@ 2* 2* wrfram4 count @ 1+ count ! next ticks swap - . ; 
\ : rfm4 0 count ! cr 10000 for block @ r@ 2* 2* rdfram4 ud. count @ dup 12345 m* ud. 1+ count ! cr next cr ;
\ : rfmt4 0 count ! ticks 10000 for block @ r@ 2* 2* rdfram4 2drop count @ 1+ count ! next ticks swap - . ;
\ wfmt4 329msecs at Fcy=27.648MHz :(
\ rfmt4 234msecs at Fcy=27.648MHz :(
\ 142.1kB/sec average


