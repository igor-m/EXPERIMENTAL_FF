\ SPI FRAM LIBRARY - BYTE WORD DOUBLE QUAD
\ v 0.4.
\ USES 16bit SPI TRANSFERS WHERE APPLICABLE
\ USES DOUBLE AS THE ADDRESS
\ ADDRESS RANGE $000000 .. $FFFFFF (16,777,215)
\
\ DISCOVERED WREN COULD BE WRITTEN WITH 16BIT !!
\ (DATASHEET SAYS AFTER 8th BIT CS\ SHALL GO HIGH)
\
\ FOR FLASHFORTH AND OTHERS
\
\ Igor Mokos (copyright) 25.5.2015
\ ALL UNDER GNU GPL v3
\ No warranties of any kind, provided as-is
\ 
\ FRAM MEMORY FM25H20 8PIN 256kBytes
\ Tested with dspic33fj128gp802
\ 
\	FRAM to PIC wiring (excl. +3.3V VCC and GND):
\
\	FRAM				dsPIC33
\	==================================================
\	fram1_S/	i		CS1 RB15	o
\	fram2_Q		o		SDI1 RB14	i
\	fram5_D		i		SDO1 RB12	o
\	fram6_CLK	i		SCK1 RB13	o
\	==================================================


-spifram
marker -spifram

decimal

\ FRAM opcodes
$06 constant FRAM_WREN 
$02 constant FRAM_WRITE 
$03 constant FRAM_READ 

$02c8 constant trisb
$02ca constant portb
$02cc constant latb
$032c constant adpcfg

$0248 constant SPI1BUF
$0242 constant SPI1CON1
$0240 constant SPI1STAT
$0742 constant OSCCON
$0770 constant PMD1

: SPI1RBF? $0001 SPI1STAT mtst ;				\ wait till SPI1RBF is 1

: FRAM_CS_H $8000 latb mset ;					\ PIN_B15 high
: FRAM_CS_L $8000 latb mclr ;					\ PIN_B15 low

: spiini
	$ffff adpcfg !						\ all RBx digital pins
	$4fff trisb !						\ RB14 input, RB12,13,15 output, 1-input 0-output
	FRAM_CS_H						\ deselect FRAM
	
	$0008 PMD1 mclr						\ enable clock to SPI1 !!!
	
	\ unlock PPS - done in FF already
	
	$ff00 #14 or $06a8 !					\ RPINR20 $06a8 RP14=#14 SDI1
	#8 #8 lshift						\ RPOR6 $06cc	SCKO1	B13 #8
	#7 or $06cc !						\ RPOR6 $06cc	SDO1	B12 #7
	
	$047e SPI1CON1 !					\ set SPI 16bit mode $047e, 8it mode $007e
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

: spi!  ( x --  )
	SPI1BUF !
	begin SPI1RBF? until
	SPI1BUF @ drop						\ must be read !!
	;

: spi@  (  -- x )
	#0 SPI1BUF !
	begin SPI1RBF? until
	SPI1BUF @
	;
	
\ read procedure for reading 1 byte from fram
: rdfram1 ( addr. -- c )
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$007e SPI1CON1 !					\ 8bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	FRAM_CS_L
	FRAM_READ spi!
	spi!	 						\ addrh
	dup							\ addr addr
	#8 rshift 
	spi!							\ addr_h
	spi!							\ addr_l
	spi@							\ x in
	FRAM_CS_H
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$047e SPI1CON1 !					\ 16bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

\ write procedure for writing 1 byte to fram
: wrfram1 ( c addr. -- )
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$007e SPI1CON1 !					\ 8bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	FRAM_CS_L
	FRAM_WRITE spi!
	spi!							\ addrh
	dup
	#8 rshift							
	spi!							\ addr_h
	spi!							\ addr_l
	spi!							\ x out
	FRAM_CS_H
	$8000 SPI1STAT mclr					\ disable SPI, SPI1EN=0
	$047e SPI1CON1 !					\ 16bit SPI mode
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

\ read procedure for reading 1 word (16bit) from fram
: rdfram2 ( addr. -- x )
	FRAM_READ #8 lshift or					\ addr FRaddrh
	FRAM_CS_L
	spi!							\ send FRaddrh
	spi!	 						\ send addr
	spi@							\ x
	FRAM_CS_H
	;

\ write procedure for writing 1 word (16bit) to fram
: wrfram2 ( x addr. -- )
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	FRAM_WRITE #8 lshift or					\ addr FWaddrh
	FRAM_CS_L
	spi!							\ FWaddrh
	spi!							\ addr
	spi!							\ x
	FRAM_CS_H
	;
	
\ read procedure for reading 1 double (32bit) from fram
: rdfram4 ( addr. -- d )
	FRAM_READ #8 lshift or					\ addr FRaddrh
	FRAM_CS_L
	spi!							\ send FRaddrh
	spi!							\ send addr
	spi@							\ x
	spi@							\ x
	swap
	FRAM_CS_H
	;

\ write procedure for writing 1 double (32bit) to fram
: wrfram4 ( d addr. -- )
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	FRAM_WRITE #8 lshift or					\ addr FWaddrh
	FRAM_CS_L
	spi!							\ FWaddrh
	spi!							\ addr
	spi!							\ x
	spi!							\ x
	FRAM_CS_H
	;

\ read procedure for reading 1 quad (64bit) from fram
: rdfram8 ( addr. -- q )
	FRAM_READ #8 lshift or					\ addr FRaddrh
	FRAM_CS_L
	spi!							\ send FRaddrh
	spi!							\ send addr
	spi@							\ 
	>r							\ r:d
	spi@							\ c 
	spi@							\ 
	spi@							\ c b a
	swap							\ c a b
	rot							\ a b c
	r>							\ a b c d
	FRAM_CS_H
	;

\ write procedure for writing 1 quad (64bit) to fram
: wrfram8 ( q addr. -- )
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	FRAM_WRITE #8 lshift or					\ addr FWaddrh
	FRAM_CS_L
	spi!							\ FWaddrh
	spi!							\ addr
	spi!							\ x
	spi!							\ x
	spi!							\ x
	spi!							\ x
	FRAM_CS_H
	;
	
\ TESTING:

2variable data 
$1234 $5678 data 2!	
variable block
2 block !
variable count

spiini

\ data 2@

hex

$88 $17777. wrfram1 $17777. rdfram1
$1234 $12345. wrfram2 $12345. rdfram2
$4321 $8765 $23456. wrfram4 $23456. rdfram4 
$abcd $ef89 $1234 $5678 $20405. wrfram8 $20405. rdfram8

decimal

\ Write and Read 40kB of data
\
\ : rfm1a 0 count ! cr 40000 for r@ s>d rdfram1 u. count @ dup u. cr  1 + count ! next ;
\ : wfmt1 ticks 40000 for data @ r@ s>d wrfram1 next ticks swap - . ; 
\ : rfm1 40000 for r@ s>d rdfram1 . cr next ;
\ : rfmt1 ticks 40000 for r@ s>d rdfram1 drop next ticks swap - . ;
\ wfmt1 1090msecs at Fcy=27.648MHz :(
\ rfmt1  876msecs at Fcy=27.648MHz :(

\ Write and Read 40kB of data
\
\ : wfmt2 0 count ! ticks 20000 for count @ r@ 2* s>d wrfram2 count @ 1+ count ! next ticks swap - . ; 
\ : rfm2 0 count ! cr 20000 for r@ 2* s>d rdfram2 u. count @ dup u. 1+ count ! cr next cr ;
\ : rfmt2 0 count ! ticks 20000 for r@ 2* s>d rdfram2 drop count @ 1+ count ! next ticks swap - . ;
\ wfmt2 505msecs at Fcy=27.648MHz :(
\ rfmt2 365msecs at Fcy=27.648MHz :(

\ Write and Read 40kB of data
\
\ : wfmt4 0 count ! ticks 10000 for count @ 12345 m* r@ 2* 2* s>d wrfram4 count @ 1+ count ! next ticks swap - . ; 
\ : rfm4 0 count ! cr 10000 for r@ 2* 2* s>d rdfram4 ud. count @ dup 12345 m* ud. 1+ count ! cr next cr ;
\ : rfmt4 0 count ! ticks 10000 for r@ 2* 2* s>d rdfram4 2drop count @ 1+ count ! next ticks swap - . ;
\ wfmt4 304msecs at Fcy=27.648MHz :)
\ rfmt4 230msecs at Fcy=27.648MHz :)

\ Write and Read 40kB of data
\
\ : wfmt8 0 count ! ticks 5000 for count @ 12345 m* 2dup r@ 2* 2* 2* s>d wrfram8 count @ 1+ count ! next ticks swap - . ; 
\ : rfmt8 0 count ! ticks 5000 for r@ 2* 2* 2* s>d rdfram8 2drop 2drop count @ 1+ count ! next ticks swap - . ;
\ wfmt8 202msecs at Fcy=27.648MHz :)
\ rfmt8 164msecs at Fcy=27.648MHz :) 



