\ SPI FRAM LIBRARY - WRITE READ BYTES
\ FOR FLASHFORTH
\ c IgorM 5/2015
\ GNU GPL v3
\ No warranties of any kind
\ 
\ FRAM 256kBytes FM25H20
\ peripheral pins SPI mapping:
\ SPI1 to FRAM pins:
\   fram1_S/ i------CS1 RB15 o
\   fram2_Q o-------SDI1 RB14 i
\   fram5_D i-------SDO1 RB12 o
\   fram6_CLK i-----SCK1 RB13 o
\
\ tested with dspic33fj128gp802

-spifram
marker -spifram

decimal

\ FRAM opcodes
$06 constant FRAM_WREN 
$02 constant FRAM_WRITE 
$03 constant FRAM_READ 

$02c8 constant trisb
$02ca constant portb
$02cc constant latb
$032c constant adpcfg

$0248 constant SPI1BUF
$0242 constant SPI1CON1
$0240 constant SPI1STAT
$0742 constant OSCCON
$0770 constant PMD1

: SPI1RBF? $0001 SPI1STAT mtst ;			\ wait till SPI1RBF is 1

: FRAM_CS_H $8000 latb mset ;			\ PIN_B15 high
: FRAM_CS_L $8000 latb mclr ;			\ PIN_B15 low

: spiini
	$ffff adpcfg !						\ all RBx digital pins
	$4fff trisb !						\ RB14 input, RB12,13,15 output, 1-input 0-output
	FRAM_CS_H							\ deselect FRAM
	
	$0008 PMD1 mclr						\ enable clock to SPI1 !!!
	
	\ unlock PPS - done in FF already
	\ $46 OSCCON c!						\ Write 0x46 to OSCCON<7:0>.
	\ $57 OSCCON c!						\ Write 0x57 to OSCCON<7:0>.
	\ $0020 OSCCON mclr					\ Clear <bit6>IOLOCK as a single operation.
    
	$ff00 #14 or $06a8 !				\ RPINR20 $06a8 RP14=#14 SDI1
    #8 #8 lshift						\ RPOR6 $06cc	SCKO1  B13 #8
    #7 or $06cc ! 						\ RPOR6 $06cc 	SDO1   B12 #7
	
	\ lock PPS
	\ $46 OSCCON c!						\ Write 0x46 to OSCCON<7:0>.
	\ $57 OSCCON c!						\ Write 0x57 to OSCCON<7:0>.
	\ $0020 OSCCON mset					\ Set <bit6>IOLOCK as a single operation.

	$007e SPI1CON1 !   					\ set SPI mode $007e, also $027e works
	$8000 SPI1STAT mset					\ enable SPI, SPI1EN=1
	;

: spi!  ( x --  )
	SPI1BUF !
	begin SPI1RBF? until
	SPI1BUF @ drop						\ must be read !!
	;
	
: spi@  (  -- x )
	#0 SPI1BUF !
	begin SPI1RBF? until
	SPI1BUF @
	;
	
\ read procedure for reading 1 byte from fram
: rdfram ( addrh addr -- x )
	dup
	rot
	FRAM_CS_L
	FRAM_READ spi!
	spi!	 							\ addrh
	#8 rshift 
	spi!								\ addr_h
	spi!								\ addr_l
	spi@								\ x in
	FRAM_CS_H
	;

\ write procedure for writing 1 byte to	fram
: wrfram ( x addrh addr -- )
	dup
	rot
	FRAM_CS_L
	FRAM_WREN spi!
	FRAM_CS_H
	FRAM_CS_L
	FRAM_WRITE spi!
	spi!								\ addrh
	#8 rshift 							
	spi!								\ addr_h
	spi!								\ addr_l
	spi!								\ x out
	FRAM_CS_H
	;

\ variable data 
\ 181 data !	
\ variable block
\ 2 block !
\ variable count

\ spiini

\ : rfm 0 count ! cr 20000 for block @ r@ rdfram u. count @ dup u. cr  1 + count ! next ;
\ : wfmt ticks 20000 for data @ block @ r@ wrfram next ticks swap - . ; 
\ : rfm 20000 for block @ r@ rdfram . cr next ;
\ : rfmt ticks 20000 for block @ r@ rdfram drop next ticks swap - . ;

\ wfmt 480msecs at 27.648MHz :(
\ rfmt 373msecs at 27.648MHz :(

	
	

